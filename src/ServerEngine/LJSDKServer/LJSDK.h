// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `LJSDK.jce'
// **********************************************************************

#ifndef __LJSDK_H_
#define __LJSDK_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace ServerEngine
{
    enum VerifyKeyRetCode
    {
        en_OK = 0,
        en_ERROR = 1,
        en_EXCEPTION = 2,
        en_NEEDCOIN = 3,
        en_INVALIDLOGIN = 4,
        en_INVALIDCHANNEL = 5,
    };
    inline string etos(const VerifyKeyRetCode & e)
    {
        switch(e)
        {
            case en_OK: return "en_OK";
            case en_ERROR: return "en_ERROR";
            case en_EXCEPTION: return "en_EXCEPTION";
            case en_NEEDCOIN: return "en_NEEDCOIN";
            case en_INVALIDLOGIN: return "en_INVALIDLOGIN";
            case en_INVALIDCHANNEL: return "en_INVALIDCHANNEL";
            default: return "";
        }
        return "";
    }
    inline int stoe(const string & s, VerifyKeyRetCode & e)
    {
        if(s == "en_OK")  { e=en_OK; return 0;}
        if(s == "en_ERROR")  { e=en_ERROR; return 0;}
        if(s == "en_EXCEPTION")  { e=en_EXCEPTION; return 0;}
        if(s == "en_NEEDCOIN")  { e=en_NEEDCOIN; return 0;}
        if(s == "en_INVALIDLOGIN")  { e=en_INVALIDLOGIN; return 0;}
        if(s == "en_INVALIDCHANNEL")  { e=en_INVALIDCHANNEL; return 0;}

        return -1;
    }

    enum IOSVerifyRetcode
    {
        en_IOS_VERIFY_OK = 0,
        en_IOS_VERIFY_VERIFY_FALSE = 1,
        en_IOS_VERIFY_NET_ERROR = 2,
    };
    inline string etos(const IOSVerifyRetcode & e)
    {
        switch(e)
        {
            case en_IOS_VERIFY_OK: return "en_IOS_VERIFY_OK";
            case en_IOS_VERIFY_VERIFY_FALSE: return "en_IOS_VERIFY_VERIFY_FALSE";
            case en_IOS_VERIFY_NET_ERROR: return "en_IOS_VERIFY_NET_ERROR";
            default: return "";
        }
        return "";
    }
    inline int stoe(const string & s, IOSVerifyRetcode & e)
    {
        if(s == "en_IOS_VERIFY_OK")  { e=en_IOS_VERIFY_OK; return 0;}
        if(s == "en_IOS_VERIFY_VERIFY_FALSE")  { e=en_IOS_VERIFY_VERIFY_FALSE; return 0;}
        if(s == "en_IOS_VERIFY_NET_ERROR")  { e=en_IOS_VERIFY_NET_ERROR; return 0;}

        return -1;
    }

    struct VerifyKey : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "ServerEngine.VerifyKey";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        VerifyKey()
        :strUserId(""),strToken(""),strChannelId(""),strProductCode(""),strChannelLabel("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(strUserId, 0);
            _os.write(strToken, 1);
            _os.write(strChannelId, 2);
            _os.write(strProductCode, 3);
            _os.write(strChannelLabel, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(strUserId, 0, true);
            _is.read(strToken, 1, true);
            _is.read(strChannelId, 2, true);
            _is.read(strProductCode, 3, true);
            _is.read(strChannelLabel, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(strUserId,"strUserId");
            _ds.display(strToken,"strToken");
            _ds.display(strChannelId,"strChannelId");
            _ds.display(strProductCode,"strProductCode");
            _ds.display(strChannelLabel,"strChannelLabel");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(strUserId, true);
            _ds.displaySimple(strToken, true);
            _ds.displaySimple(strChannelId, true);
            _ds.displaySimple(strProductCode, true);
            _ds.displaySimple(strChannelLabel, false);
            return _os;
        }
    public:
        std::string strUserId;
        std::string strToken;
        std::string strChannelId;
        std::string strProductCode;
        std::string strChannelLabel;
    };
    inline bool operator==(const VerifyKey&l, const VerifyKey&r)
    {
        return l.strUserId == r.strUserId && l.strToken == r.strToken && l.strChannelId == r.strChannelId && l.strProductCode == r.strProductCode && l.strChannelLabel == r.strChannelLabel;
    }
    inline bool operator!=(const VerifyKey&l, const VerifyKey&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class LJSDKPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~LJSDKPrxCallback(){}
        virtual void callback_verifyUserLogin(taf::Int32 iState)
        { throw std::runtime_error("callback_verifyUserLogin() overloading incorrect."); }
        virtual void callback_verifyUserLogin_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_verifyUserLogin_exception() overloading incorrect."); }

        virtual void callback_getPhoneStream()
        { throw std::runtime_error("callback_getPhoneStream() overloading incorrect."); }
        virtual void callback_getPhoneStream_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getPhoneStream_exception() overloading incorrect."); }

        virtual void callback_VIVOPostPerPay( const std::string& strAccessKey,  const std::string& strOrderNumber, taf::Int32 price)
        { throw std::runtime_error("callback_VIVOPostPerPay() overloading incorrect."); }
        virtual void callback_VIVOPostPerPay_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_VIVOPostPerPay_exception() overloading incorrect."); }

        virtual void callback_iosPay( const std::string& stransID,  const std::string& productID, taf::Int32 sPrice, taf::Int32 quantity, ServerEngine::IOSVerifyRetcode retCode)
        { throw std::runtime_error("callback_iosPay() overloading incorrect."); }
        virtual void callback_iosPay_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_iosPay_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<LJSDKPrxCallback> LJSDKPrxCallbackPtr;

    /* proxy for client */
    class LJSDKProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        void verifyUserLogin(const ServerEngine::VerifyKey & verifyKey,taf::Int32 &iState,const map<string, string> &context = TAF_CONTEXT());
        void async_verifyUserLogin(LJSDKPrxCallbackPtr callback,const ServerEngine::VerifyKey & verifyKey,const map<string, string> &context = TAF_CONTEXT());

        void getPhoneStream(const std::string & strUrl,const map<string, string> &context = TAF_CONTEXT());
        void async_getPhoneStream(LJSDKPrxCallbackPtr callback,const std::string & strUrl,const map<string, string> &context = TAF_CONTEXT());

        void VIVOPostPerPay(const std::string & strPostContext,std::string &strAccessKey,std::string &strOrderNumber,taf::Int32 &price,const map<string, string> &context = TAF_CONTEXT());
        void async_VIVOPostPerPay(LJSDKPrxCallbackPtr callback,const std::string & strPostContext,const map<string, string> &context = TAF_CONTEXT());

        void iosPay(taf::Int32 worldID,const std::string & account,taf::Int32 cPrice,const std::string & receipt,std::string &stransID,std::string &productID,taf::Int32 &sPrice,taf::Int32 &quantity,ServerEngine::IOSVerifyRetcode &retCode,const map<string, string> &context = TAF_CONTEXT());
        void async_iosPay(LJSDKPrxCallbackPtr callback,taf::Int32 worldID,const std::string & account,taf::Int32 cPrice,const std::string & receipt,const map<string, string> &context = TAF_CONTEXT());

        LJSDKProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<LJSDKProxy> LJSDKPrx;

    /* servant for server */
    class LJSDK : public taf::Servant
    {
    public:
        virtual ~LJSDK(){}
        virtual void verifyUserLogin(const ServerEngine::VerifyKey & verifyKey,taf::Int32 &iState,taf::JceCurrentPtr current) = 0;
        static void async_response_verifyUserLogin(taf::JceCurrentPtr current, taf::Int32 iState);

        virtual void getPhoneStream(const std::string & strUrl,taf::JceCurrentPtr current) = 0;
        static void async_response_getPhoneStream(taf::JceCurrentPtr current);

        virtual void VIVOPostPerPay(const std::string & strPostContext,std::string &strAccessKey,std::string &strOrderNumber,taf::Int32 &price,taf::JceCurrentPtr current) = 0;
        static void async_response_VIVOPostPerPay(taf::JceCurrentPtr current, const std::string &strAccessKey, const std::string &strOrderNumber, taf::Int32 price);

        virtual void iosPay(taf::Int32 worldID,const std::string & account,taf::Int32 cPrice,const std::string & receipt,std::string &stransID,std::string &productID,taf::Int32 &sPrice,taf::Int32 &quantity,ServerEngine::IOSVerifyRetcode &retCode,taf::JceCurrentPtr current) = 0;
        static void async_response_iosPay(taf::JceCurrentPtr current, const std::string &stransID, const std::string &productID, taf::Int32 sPrice, taf::Int32 quantity, ServerEngine::IOSVerifyRetcode retCode);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define ServerEngine_VerifyKey_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.strUserId,b.strUserId);jce_copy_struct(a.strToken,b.strToken);jce_copy_struct(a.strChannelId,b.strChannelId);jce_copy_struct(a.strProductCode,b.strProductCode);jce_copy_struct(a.strChannelLabel,b.strChannelLabel);



#endif
