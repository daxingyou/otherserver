// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `ConvertCode.jce'
// **********************************************************************

#ifndef __CONVERTCODE_H_
#define __CONVERTCODE_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace ServerEngine
{
    enum ConvertCodeRet
    {
        en_ConvertCodeRet_OK = 0,
        en_ConvertCodeRet_NoData = 1,
        en_ConvertCodeRet_Fail = 2,
    };
    inline string etos(const ConvertCodeRet & e)
    {
        switch(e)
        {
            case en_ConvertCodeRet_OK: return "en_ConvertCodeRet_OK";
            case en_ConvertCodeRet_NoData: return "en_ConvertCodeRet_NoData";
            case en_ConvertCodeRet_Fail: return "en_ConvertCodeRet_Fail";
            default: return "";
        }
        return "";
    }
    inline int stoe(const string & s, ConvertCodeRet & e)
    {
        if(s == "en_ConvertCodeRet_OK")  { e=en_ConvertCodeRet_OK; return 0;}
        if(s == "en_ConvertCodeRet_NoData")  { e=en_ConvertCodeRet_NoData; return 0;}
        if(s == "en_ConvertCodeRet_Fail")  { e=en_ConvertCodeRet_Fail; return 0;}

        return -1;
    }

    enum ConvertCodeState
    {
        en_ConvertCodeState_None = 0,
        en_ConvertCodeState_CanConvert = 1,
        en_ConvertCodeState_HaveConvert = 2,
    };
    inline string etos(const ConvertCodeState & e)
    {
        switch(e)
        {
            case en_ConvertCodeState_None: return "en_ConvertCodeState_None";
            case en_ConvertCodeState_CanConvert: return "en_ConvertCodeState_CanConvert";
            case en_ConvertCodeState_HaveConvert: return "en_ConvertCodeState_HaveConvert";
            default: return "";
        }
        return "";
    }
    inline int stoe(const string & s, ConvertCodeState & e)
    {
        if(s == "en_ConvertCodeState_None")  { e=en_ConvertCodeState_None; return 0;}
        if(s == "en_ConvertCodeState_CanConvert")  { e=en_ConvertCodeState_CanConvert; return 0;}
        if(s == "en_ConvertCodeState_HaveConvert")  { e=en_ConvertCodeState_HaveConvert; return 0;}

        return -1;
    }


    /* callback of async proxy for client */
    class ConvertCodePrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~ConvertCodePrxCallback(){}
        virtual void callback_updateConvertCode(taf::Int32 ret, taf::Int32 state)
        { throw std::runtime_error("callback_updateConvertCode() overloading incorrect."); }
        virtual void callback_updateConvertCode_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_updateConvertCode_exception() overloading incorrect."); }

        virtual void callback_getConvertCode(taf::Int32 ret, taf::Int32 state)
        { throw std::runtime_error("callback_getConvertCode() overloading incorrect."); }
        virtual void callback_getConvertCode_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getConvertCode_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<ConvertCodePrxCallback> ConvertCodePrxCallbackPtr;

    /* proxy for client */
    class ConvertCodeProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        taf::Int32 updateConvertCode(const std::string & convertCode,taf::Int32 &state,taf::Int32 updateState,const map<string, string> &context = TAF_CONTEXT());
        void async_updateConvertCode(ConvertCodePrxCallbackPtr callback,const std::string & convertCode,taf::Int32 updateState,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 getConvertCode(const std::string & convertCode,taf::Int32 &state,const map<string, string> &context = TAF_CONTEXT());
        void async_getConvertCode(ConvertCodePrxCallbackPtr callback,const std::string & convertCode,const map<string, string> &context = TAF_CONTEXT());

        ConvertCodeProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<ConvertCodeProxy> ConvertCodePrx;

    /* servant for server */
    class ConvertCode : public taf::Servant
    {
    public:
        virtual ~ConvertCode(){}
        virtual taf::Int32 updateConvertCode(const std::string & convertCode,taf::Int32 &state,taf::Int32 updateState,taf::JceCurrentPtr current) = 0;
        static void async_response_updateConvertCode(taf::JceCurrentPtr current, taf::Int32 _ret, taf::Int32 state);

        virtual taf::Int32 getConvertCode(const std::string & convertCode,taf::Int32 &state,taf::JceCurrentPtr current) = 0;
        static void async_response_getConvertCode(taf::JceCurrentPtr current, taf::Int32 _ret, taf::Int32 state);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}



#endif
