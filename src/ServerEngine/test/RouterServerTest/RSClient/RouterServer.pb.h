// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RouterServer.proto

#ifndef PROTOBUF_RouterServer_2eproto__INCLUDED
#define PROTOBUF_RouterServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ServerEngine {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RouterServer_2eproto();
void protobuf_AssignDesc_RouterServer_2eproto();
void protobuf_ShutdownFile_RouterServer_2eproto();

class SCMessage;
class CSMessage;
class CS_RS_Version;
class CS_RS_Auth;
class SC_RS_Auth;
class RSWorld;
class SC_RS_WorldList;
class RS_ROUTER_VERSION_SC;
class SC_RS_Error;
class CS_RS_ALogin;

enum enBusyStatus {
  en_BusyStatus_Free = 0,
  en_BusyStatus_Good = 1,
  en_BusyStatus_Hot = 2,
  en_BusyStatus_Full = 3,
  en_BusyStatus_End = 4
};
bool enBusyStatus_IsValid(int value);
const enBusyStatus enBusyStatus_MIN = en_BusyStatus_Free;
const enBusyStatus enBusyStatus_MAX = en_BusyStatus_End;
const int enBusyStatus_ARRAYSIZE = enBusyStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* enBusyStatus_descriptor();
inline const ::std::string& enBusyStatus_Name(enBusyStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    enBusyStatus_descriptor(), value);
}
inline bool enBusyStatus_Parse(
    const ::std::string& name, enBusyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<enBusyStatus>(
    enBusyStatus_descriptor(), name, value);
}
enum RouterServerCMD {
  RS_ROUTER_AUTH = 1000,
  RS_ROUTER_WORLDLIST = 1001,
  RS_ROUTER_ALOGIN = 1002,
  RS_ROUTER_ERROR = 1003,
  RS_ROUTER_VERSION = 1004
};
bool RouterServerCMD_IsValid(int value);
const RouterServerCMD RouterServerCMD_MIN = RS_ROUTER_AUTH;
const RouterServerCMD RouterServerCMD_MAX = RS_ROUTER_VERSION;
const int RouterServerCMD_ARRAYSIZE = RouterServerCMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* RouterServerCMD_descriptor();
inline const ::std::string& RouterServerCMD_Name(RouterServerCMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    RouterServerCMD_descriptor(), value);
}
inline bool RouterServerCMD_Parse(
    const ::std::string& name, RouterServerCMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RouterServerCMD>(
    RouterServerCMD_descriptor(), name, value);
}
enum RSAuthCode {
  RS_AUTU_OK = 0,
  RS_AUTU_PASSWD = 1
};
bool RSAuthCode_IsValid(int value);
const RSAuthCode RSAuthCode_MIN = RS_AUTU_OK;
const RSAuthCode RSAuthCode_MAX = RS_AUTU_PASSWD;
const int RSAuthCode_ARRAYSIZE = RSAuthCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RSAuthCode_descriptor();
inline const ::std::string& RSAuthCode_Name(RSAuthCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RSAuthCode_descriptor(), value);
}
inline bool RSAuthCode_Parse(
    const ::std::string& name, RSAuthCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RSAuthCode>(
    RSAuthCode_descriptor(), name, value);
}
// ===================================================================

class SCMessage : public ::google::protobuf::Message {
 public:
  SCMessage();
  virtual ~SCMessage();

  SCMessage(const SCMessage& from);

  inline SCMessage& operator=(const SCMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMessage& default_instance();

  void Swap(SCMessage* other);

  // implements Message ----------------------------------------------

  SCMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMessage& from);
  void MergeFrom(const SCMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iCmd = 1;
  inline bool has_icmd() const;
  inline void clear_icmd();
  static const int kICmdFieldNumber = 1;
  inline ::google::protobuf::int32 icmd() const;
  inline void set_icmd(::google::protobuf::int32 value);

  // optional bytes strMsgBody = 2;
  inline bool has_strmsgbody() const;
  inline void clear_strmsgbody();
  static const int kStrMsgBodyFieldNumber = 2;
  inline const ::std::string& strmsgbody() const;
  inline void set_strmsgbody(const ::std::string& value);
  inline void set_strmsgbody(const char* value);
  inline void set_strmsgbody(const void* value, size_t size);
  inline ::std::string* mutable_strmsgbody();
  inline ::std::string* release_strmsgbody();
  inline void set_allocated_strmsgbody(::std::string* strmsgbody);

  // @@protoc_insertion_point(class_scope:ServerEngine.SCMessage)
 private:
  inline void set_has_icmd();
  inline void clear_has_icmd();
  inline void set_has_strmsgbody();
  inline void clear_has_strmsgbody();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strmsgbody_;
  ::google::protobuf::int32 icmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static SCMessage* default_instance_;
};
// -------------------------------------------------------------------

class CSMessage : public ::google::protobuf::Message {
 public:
  CSMessage();
  virtual ~CSMessage();

  CSMessage(const CSMessage& from);

  inline CSMessage& operator=(const CSMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMessage& default_instance();

  void Swap(CSMessage* other);

  // implements Message ----------------------------------------------

  CSMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMessage& from);
  void MergeFrom(const CSMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iCmd = 1;
  inline bool has_icmd() const;
  inline void clear_icmd();
  static const int kICmdFieldNumber = 1;
  inline ::google::protobuf::int32 icmd() const;
  inline void set_icmd(::google::protobuf::int32 value);

  // optional bytes strMsgBody = 2;
  inline bool has_strmsgbody() const;
  inline void clear_strmsgbody();
  static const int kStrMsgBodyFieldNumber = 2;
  inline const ::std::string& strmsgbody() const;
  inline void set_strmsgbody(const ::std::string& value);
  inline void set_strmsgbody(const char* value);
  inline void set_strmsgbody(const void* value, size_t size);
  inline ::std::string* mutable_strmsgbody();
  inline ::std::string* release_strmsgbody();
  inline void set_allocated_strmsgbody(::std::string* strmsgbody);

  // @@protoc_insertion_point(class_scope:ServerEngine.CSMessage)
 private:
  inline void set_has_icmd();
  inline void clear_has_icmd();
  inline void set_has_strmsgbody();
  inline void clear_has_strmsgbody();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strmsgbody_;
  ::google::protobuf::int32 icmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static CSMessage* default_instance_;
};
// -------------------------------------------------------------------

class CS_RS_Version : public ::google::protobuf::Message {
 public:
  CS_RS_Version();
  virtual ~CS_RS_Version();

  CS_RS_Version(const CS_RS_Version& from);

  inline CS_RS_Version& operator=(const CS_RS_Version& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_RS_Version& default_instance();

  void Swap(CS_RS_Version* other);

  // implements Message ----------------------------------------------

  CS_RS_Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_RS_Version& from);
  void MergeFrom(const CS_RS_Version& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string codeVersion = 1;
  inline bool has_codeversion() const;
  inline void clear_codeversion();
  static const int kCodeVersionFieldNumber = 1;
  inline const ::std::string& codeversion() const;
  inline void set_codeversion(const ::std::string& value);
  inline void set_codeversion(const char* value);
  inline void set_codeversion(const char* value, size_t size);
  inline ::std::string* mutable_codeversion();
  inline ::std::string* release_codeversion();
  inline void set_allocated_codeversion(::std::string* codeversion);

  // @@protoc_insertion_point(class_scope:ServerEngine.CS_RS_Version)
 private:
  inline void set_has_codeversion();
  inline void clear_has_codeversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* codeversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static CS_RS_Version* default_instance_;
};
// -------------------------------------------------------------------

class CS_RS_Auth : public ::google::protobuf::Message {
 public:
  CS_RS_Auth();
  virtual ~CS_RS_Auth();

  CS_RS_Auth(const CS_RS_Auth& from);

  inline CS_RS_Auth& operator=(const CS_RS_Auth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_RS_Auth& default_instance();

  void Swap(CS_RS_Auth* other);

  // implements Message ----------------------------------------------

  CS_RS_Auth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_RS_Auth& from);
  void MergeFrom(const CS_RS_Auth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccount = 1;
  inline bool has_straccount() const;
  inline void clear_straccount();
  static const int kStrAccountFieldNumber = 1;
  inline const ::std::string& straccount() const;
  inline void set_straccount(const ::std::string& value);
  inline void set_straccount(const char* value);
  inline void set_straccount(const char* value, size_t size);
  inline ::std::string* mutable_straccount();
  inline ::std::string* release_straccount();
  inline void set_allocated_straccount(::std::string* straccount);

  // required bytes strMd5Passwd = 2;
  inline bool has_strmd5passwd() const;
  inline void clear_strmd5passwd();
  static const int kStrMd5PasswdFieldNumber = 2;
  inline const ::std::string& strmd5passwd() const;
  inline void set_strmd5passwd(const ::std::string& value);
  inline void set_strmd5passwd(const char* value);
  inline void set_strmd5passwd(const void* value, size_t size);
  inline ::std::string* mutable_strmd5passwd();
  inline ::std::string* release_strmd5passwd();
  inline void set_allocated_strmd5passwd(::std::string* strmd5passwd);

  // @@protoc_insertion_point(class_scope:ServerEngine.CS_RS_Auth)
 private:
  inline void set_has_straccount();
  inline void clear_has_straccount();
  inline void set_has_strmd5passwd();
  inline void clear_has_strmd5passwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccount_;
  ::std::string* strmd5passwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static CS_RS_Auth* default_instance_;
};
// -------------------------------------------------------------------

class SC_RS_Auth : public ::google::protobuf::Message {
 public:
  SC_RS_Auth();
  virtual ~SC_RS_Auth();

  SC_RS_Auth(const SC_RS_Auth& from);

  inline SC_RS_Auth& operator=(const SC_RS_Auth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_RS_Auth& default_instance();

  void Swap(SC_RS_Auth* other);

  // implements Message ----------------------------------------------

  SC_RS_Auth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_RS_Auth& from);
  void MergeFrom(const SC_RS_Auth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccount = 1;
  inline bool has_straccount() const;
  inline void clear_straccount();
  static const int kStrAccountFieldNumber = 1;
  inline const ::std::string& straccount() const;
  inline void set_straccount(const ::std::string& value);
  inline void set_straccount(const char* value);
  inline void set_straccount(const char* value, size_t size);
  inline ::std::string* mutable_straccount();
  inline ::std::string* release_straccount();
  inline void set_allocated_straccount(::std::string* straccount);

  // required int32 iRetCode = 2;
  inline bool has_iretcode() const;
  inline void clear_iretcode();
  static const int kIRetCodeFieldNumber = 2;
  inline ::google::protobuf::int32 iretcode() const;
  inline void set_iretcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ServerEngine.SC_RS_Auth)
 private:
  inline void set_has_straccount();
  inline void clear_has_straccount();
  inline void set_has_iretcode();
  inline void clear_has_iretcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccount_;
  ::google::protobuf::int32 iretcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static SC_RS_Auth* default_instance_;
};
// -------------------------------------------------------------------

class RSWorld : public ::google::protobuf::Message {
 public:
  RSWorld();
  virtual ~RSWorld();

  RSWorld(const RSWorld& from);

  inline RSWorld& operator=(const RSWorld& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSWorld& default_instance();

  void Swap(RSWorld* other);

  // implements Message ----------------------------------------------

  RSWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RSWorld& from);
  void MergeFrom(const RSWorld& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iWorldID = 1;
  inline bool has_iworldid() const;
  inline void clear_iworldid();
  static const int kIWorldIDFieldNumber = 1;
  inline ::google::protobuf::int32 iworldid() const;
  inline void set_iworldid(::google::protobuf::int32 value);

  // required string strWorldName = 2;
  inline bool has_strworldname() const;
  inline void clear_strworldname();
  static const int kStrWorldNameFieldNumber = 2;
  inline const ::std::string& strworldname() const;
  inline void set_strworldname(const ::std::string& value);
  inline void set_strworldname(const char* value);
  inline void set_strworldname(const char* value, size_t size);
  inline ::std::string* mutable_strworldname();
  inline ::std::string* release_strworldname();
  inline void set_allocated_strworldname(::std::string* strworldname);

  // required int32 iAtt = 3;
  inline bool has_iatt() const;
  inline void clear_iatt();
  static const int kIAttFieldNumber = 3;
  inline ::google::protobuf::int32 iatt() const;
  inline void set_iatt(::google::protobuf::int32 value);

  // required int32 iOnlineStatus = 4;
  inline bool has_ionlinestatus() const;
  inline void clear_ionlinestatus();
  static const int kIOnlineStatusFieldNumber = 4;
  inline ::google::protobuf::int32 ionlinestatus() const;
  inline void set_ionlinestatus(::google::protobuf::int32 value);

  // required int32 iBusyStatus = 5;
  inline bool has_ibusystatus() const;
  inline void clear_ibusystatus();
  static const int kIBusyStatusFieldNumber = 5;
  inline ::google::protobuf::int32 ibusystatus() const;
  inline void set_ibusystatus(::google::protobuf::int32 value);

  // optional bool bHaveRole = 6;
  inline bool has_bhaverole() const;
  inline void clear_bhaverole();
  static const int kBHaveRoleFieldNumber = 6;
  inline bool bhaverole() const;
  inline void set_bhaverole(bool value);

  // @@protoc_insertion_point(class_scope:ServerEngine.RSWorld)
 private:
  inline void set_has_iworldid();
  inline void clear_has_iworldid();
  inline void set_has_strworldname();
  inline void clear_has_strworldname();
  inline void set_has_iatt();
  inline void clear_has_iatt();
  inline void set_has_ionlinestatus();
  inline void clear_has_ionlinestatus();
  inline void set_has_ibusystatus();
  inline void clear_has_ibusystatus();
  inline void set_has_bhaverole();
  inline void clear_has_bhaverole();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strworldname_;
  ::google::protobuf::int32 iworldid_;
  ::google::protobuf::int32 iatt_;
  ::google::protobuf::int32 ionlinestatus_;
  ::google::protobuf::int32 ibusystatus_;
  bool bhaverole_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static RSWorld* default_instance_;
};
// -------------------------------------------------------------------

class SC_RS_WorldList : public ::google::protobuf::Message {
 public:
  SC_RS_WorldList();
  virtual ~SC_RS_WorldList();

  SC_RS_WorldList(const SC_RS_WorldList& from);

  inline SC_RS_WorldList& operator=(const SC_RS_WorldList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_RS_WorldList& default_instance();

  void Swap(SC_RS_WorldList* other);

  // implements Message ----------------------------------------------

  SC_RS_WorldList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_RS_WorldList& from);
  void MergeFrom(const SC_RS_WorldList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ServerEngine.RSWorld worldList = 1;
  inline int worldlist_size() const;
  inline void clear_worldlist();
  static const int kWorldListFieldNumber = 1;
  inline const ::ServerEngine::RSWorld& worldlist(int index) const;
  inline ::ServerEngine::RSWorld* mutable_worldlist(int index);
  inline ::ServerEngine::RSWorld* add_worldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ServerEngine::RSWorld >&
      worldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ServerEngine::RSWorld >*
      mutable_worldlist();

  // @@protoc_insertion_point(class_scope:ServerEngine.SC_RS_WorldList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ServerEngine::RSWorld > worldlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static SC_RS_WorldList* default_instance_;
};
// -------------------------------------------------------------------

class RS_ROUTER_VERSION_SC : public ::google::protobuf::Message {
 public:
  RS_ROUTER_VERSION_SC();
  virtual ~RS_ROUTER_VERSION_SC();

  RS_ROUTER_VERSION_SC(const RS_ROUTER_VERSION_SC& from);

  inline RS_ROUTER_VERSION_SC& operator=(const RS_ROUTER_VERSION_SC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RS_ROUTER_VERSION_SC& default_instance();

  void Swap(RS_ROUTER_VERSION_SC* other);

  // implements Message ----------------------------------------------

  RS_ROUTER_VERSION_SC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RS_ROUTER_VERSION_SC& from);
  void MergeFrom(const RS_ROUTER_VERSION_SC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strUrlDir = 1;
  inline bool has_strurldir() const;
  inline void clear_strurldir();
  static const int kStrUrlDirFieldNumber = 1;
  inline const ::std::string& strurldir() const;
  inline void set_strurldir(const ::std::string& value);
  inline void set_strurldir(const char* value);
  inline void set_strurldir(const char* value, size_t size);
  inline ::std::string* mutable_strurldir();
  inline ::std::string* release_strurldir();
  inline void set_allocated_strurldir(::std::string* strurldir);

  // required string strVersion = 2;
  inline bool has_strversion() const;
  inline void clear_strversion();
  static const int kStrVersionFieldNumber = 2;
  inline const ::std::string& strversion() const;
  inline void set_strversion(const ::std::string& value);
  inline void set_strversion(const char* value);
  inline void set_strversion(const char* value, size_t size);
  inline ::std::string* mutable_strversion();
  inline ::std::string* release_strversion();
  inline void set_allocated_strversion(::std::string* strversion);

  // optional string strMinVersion = 3;
  inline bool has_strminversion() const;
  inline void clear_strminversion();
  static const int kStrMinVersionFieldNumber = 3;
  inline const ::std::string& strminversion() const;
  inline void set_strminversion(const ::std::string& value);
  inline void set_strminversion(const char* value);
  inline void set_strminversion(const char* value, size_t size);
  inline ::std::string* mutable_strminversion();
  inline ::std::string* release_strminversion();
  inline void set_allocated_strminversion(::std::string* strminversion);

  // optional bool noResUpdate = 4;
  inline bool has_noresupdate() const;
  inline void clear_noresupdate();
  static const int kNoResUpdateFieldNumber = 4;
  inline bool noresupdate() const;
  inline void set_noresupdate(bool value);

  // @@protoc_insertion_point(class_scope:ServerEngine.RS_ROUTER_VERSION_SC)
 private:
  inline void set_has_strurldir();
  inline void clear_has_strurldir();
  inline void set_has_strversion();
  inline void clear_has_strversion();
  inline void set_has_strminversion();
  inline void clear_has_strminversion();
  inline void set_has_noresupdate();
  inline void clear_has_noresupdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strurldir_;
  ::std::string* strversion_;
  ::std::string* strminversion_;
  bool noresupdate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static RS_ROUTER_VERSION_SC* default_instance_;
};
// -------------------------------------------------------------------

class SC_RS_Error : public ::google::protobuf::Message {
 public:
  SC_RS_Error();
  virtual ~SC_RS_Error();

  SC_RS_Error(const SC_RS_Error& from);

  inline SC_RS_Error& operator=(const SC_RS_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_RS_Error& default_instance();

  void Swap(SC_RS_Error* other);

  // implements Message ----------------------------------------------

  SC_RS_Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_RS_Error& from);
  void MergeFrom(const SC_RS_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string strErrorMsg = 1;
  inline bool has_strerrormsg() const;
  inline void clear_strerrormsg();
  static const int kStrErrorMsgFieldNumber = 1;
  inline const ::std::string& strerrormsg() const;
  inline void set_strerrormsg(const ::std::string& value);
  inline void set_strerrormsg(const char* value);
  inline void set_strerrormsg(const char* value, size_t size);
  inline ::std::string* mutable_strerrormsg();
  inline ::std::string* release_strerrormsg();
  inline void set_allocated_strerrormsg(::std::string* strerrormsg);

  // @@protoc_insertion_point(class_scope:ServerEngine.SC_RS_Error)
 private:
  inline void set_has_strerrormsg();
  inline void clear_has_strerrormsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strerrormsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static SC_RS_Error* default_instance_;
};
// -------------------------------------------------------------------

class CS_RS_ALogin : public ::google::protobuf::Message {
 public:
  CS_RS_ALogin();
  virtual ~CS_RS_ALogin();

  CS_RS_ALogin(const CS_RS_ALogin& from);

  inline CS_RS_ALogin& operator=(const CS_RS_ALogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_RS_ALogin& default_instance();

  void Swap(CS_RS_ALogin* other);

  // implements Message ----------------------------------------------

  CS_RS_ALogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_RS_ALogin& from);
  void MergeFrom(const CS_RS_ALogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iWorldID = 1;
  inline bool has_iworldid() const;
  inline void clear_iworldid();
  static const int kIWorldIDFieldNumber = 1;
  inline ::google::protobuf::int32 iworldid() const;
  inline void set_iworldid(::google::protobuf::int32 value);

  // required bytes strTransMsg = 2;
  inline bool has_strtransmsg() const;
  inline void clear_strtransmsg();
  static const int kStrTransMsgFieldNumber = 2;
  inline const ::std::string& strtransmsg() const;
  inline void set_strtransmsg(const ::std::string& value);
  inline void set_strtransmsg(const char* value);
  inline void set_strtransmsg(const void* value, size_t size);
  inline ::std::string* mutable_strtransmsg();
  inline ::std::string* release_strtransmsg();
  inline void set_allocated_strtransmsg(::std::string* strtransmsg);

  // @@protoc_insertion_point(class_scope:ServerEngine.CS_RS_ALogin)
 private:
  inline void set_has_iworldid();
  inline void clear_has_iworldid();
  inline void set_has_strtransmsg();
  inline void clear_has_strtransmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strtransmsg_;
  ::google::protobuf::int32 iworldid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RouterServer_2eproto();
  friend void protobuf_AssignDesc_RouterServer_2eproto();
  friend void protobuf_ShutdownFile_RouterServer_2eproto();

  void InitAsDefaultInstance();
  static CS_RS_ALogin* default_instance_;
};
// ===================================================================


// ===================================================================

// SCMessage

// required int32 iCmd = 1;
inline bool SCMessage::has_icmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCMessage::set_has_icmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCMessage::clear_has_icmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCMessage::clear_icmd() {
  icmd_ = 0;
  clear_has_icmd();
}
inline ::google::protobuf::int32 SCMessage::icmd() const {
  return icmd_;
}
inline void SCMessage::set_icmd(::google::protobuf::int32 value) {
  set_has_icmd();
  icmd_ = value;
}

// optional bytes strMsgBody = 2;
inline bool SCMessage::has_strmsgbody() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SCMessage::set_has_strmsgbody() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SCMessage::clear_has_strmsgbody() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SCMessage::clear_strmsgbody() {
  if (strmsgbody_ != &::google::protobuf::internal::kEmptyString) {
    strmsgbody_->clear();
  }
  clear_has_strmsgbody();
}
inline const ::std::string& SCMessage::strmsgbody() const {
  return *strmsgbody_;
}
inline void SCMessage::set_strmsgbody(const ::std::string& value) {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  strmsgbody_->assign(value);
}
inline void SCMessage::set_strmsgbody(const char* value) {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  strmsgbody_->assign(value);
}
inline void SCMessage::set_strmsgbody(const void* value, size_t size) {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  strmsgbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCMessage::mutable_strmsgbody() {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  return strmsgbody_;
}
inline ::std::string* SCMessage::release_strmsgbody() {
  clear_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmsgbody_;
    strmsgbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SCMessage::set_allocated_strmsgbody(::std::string* strmsgbody) {
  if (strmsgbody_ != &::google::protobuf::internal::kEmptyString) {
    delete strmsgbody_;
  }
  if (strmsgbody) {
    set_has_strmsgbody();
    strmsgbody_ = strmsgbody;
  } else {
    clear_has_strmsgbody();
    strmsgbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMessage

// required int32 iCmd = 1;
inline bool CSMessage::has_icmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMessage::set_has_icmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMessage::clear_has_icmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMessage::clear_icmd() {
  icmd_ = 0;
  clear_has_icmd();
}
inline ::google::protobuf::int32 CSMessage::icmd() const {
  return icmd_;
}
inline void CSMessage::set_icmd(::google::protobuf::int32 value) {
  set_has_icmd();
  icmd_ = value;
}

// optional bytes strMsgBody = 2;
inline bool CSMessage::has_strmsgbody() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMessage::set_has_strmsgbody() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMessage::clear_has_strmsgbody() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMessage::clear_strmsgbody() {
  if (strmsgbody_ != &::google::protobuf::internal::kEmptyString) {
    strmsgbody_->clear();
  }
  clear_has_strmsgbody();
}
inline const ::std::string& CSMessage::strmsgbody() const {
  return *strmsgbody_;
}
inline void CSMessage::set_strmsgbody(const ::std::string& value) {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  strmsgbody_->assign(value);
}
inline void CSMessage::set_strmsgbody(const char* value) {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  strmsgbody_->assign(value);
}
inline void CSMessage::set_strmsgbody(const void* value, size_t size) {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  strmsgbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMessage::mutable_strmsgbody() {
  set_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    strmsgbody_ = new ::std::string;
  }
  return strmsgbody_;
}
inline ::std::string* CSMessage::release_strmsgbody() {
  clear_has_strmsgbody();
  if (strmsgbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmsgbody_;
    strmsgbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMessage::set_allocated_strmsgbody(::std::string* strmsgbody) {
  if (strmsgbody_ != &::google::protobuf::internal::kEmptyString) {
    delete strmsgbody_;
  }
  if (strmsgbody) {
    set_has_strmsgbody();
    strmsgbody_ = strmsgbody;
  } else {
    clear_has_strmsgbody();
    strmsgbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CS_RS_Version

// optional string codeVersion = 1;
inline bool CS_RS_Version::has_codeversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_RS_Version::set_has_codeversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_RS_Version::clear_has_codeversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_RS_Version::clear_codeversion() {
  if (codeversion_ != &::google::protobuf::internal::kEmptyString) {
    codeversion_->clear();
  }
  clear_has_codeversion();
}
inline const ::std::string& CS_RS_Version::codeversion() const {
  return *codeversion_;
}
inline void CS_RS_Version::set_codeversion(const ::std::string& value) {
  set_has_codeversion();
  if (codeversion_ == &::google::protobuf::internal::kEmptyString) {
    codeversion_ = new ::std::string;
  }
  codeversion_->assign(value);
}
inline void CS_RS_Version::set_codeversion(const char* value) {
  set_has_codeversion();
  if (codeversion_ == &::google::protobuf::internal::kEmptyString) {
    codeversion_ = new ::std::string;
  }
  codeversion_->assign(value);
}
inline void CS_RS_Version::set_codeversion(const char* value, size_t size) {
  set_has_codeversion();
  if (codeversion_ == &::google::protobuf::internal::kEmptyString) {
    codeversion_ = new ::std::string;
  }
  codeversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_RS_Version::mutable_codeversion() {
  set_has_codeversion();
  if (codeversion_ == &::google::protobuf::internal::kEmptyString) {
    codeversion_ = new ::std::string;
  }
  return codeversion_;
}
inline ::std::string* CS_RS_Version::release_codeversion() {
  clear_has_codeversion();
  if (codeversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = codeversion_;
    codeversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_RS_Version::set_allocated_codeversion(::std::string* codeversion) {
  if (codeversion_ != &::google::protobuf::internal::kEmptyString) {
    delete codeversion_;
  }
  if (codeversion) {
    set_has_codeversion();
    codeversion_ = codeversion;
  } else {
    clear_has_codeversion();
    codeversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CS_RS_Auth

// required string strAccount = 1;
inline bool CS_RS_Auth::has_straccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_RS_Auth::set_has_straccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_RS_Auth::clear_has_straccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_RS_Auth::clear_straccount() {
  if (straccount_ != &::google::protobuf::internal::kEmptyString) {
    straccount_->clear();
  }
  clear_has_straccount();
}
inline const ::std::string& CS_RS_Auth::straccount() const {
  return *straccount_;
}
inline void CS_RS_Auth::set_straccount(const ::std::string& value) {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  straccount_->assign(value);
}
inline void CS_RS_Auth::set_straccount(const char* value) {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  straccount_->assign(value);
}
inline void CS_RS_Auth::set_straccount(const char* value, size_t size) {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  straccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_RS_Auth::mutable_straccount() {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  return straccount_;
}
inline ::std::string* CS_RS_Auth::release_straccount() {
  clear_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccount_;
    straccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_RS_Auth::set_allocated_straccount(::std::string* straccount) {
  if (straccount_ != &::google::protobuf::internal::kEmptyString) {
    delete straccount_;
  }
  if (straccount) {
    set_has_straccount();
    straccount_ = straccount;
  } else {
    clear_has_straccount();
    straccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes strMd5Passwd = 2;
inline bool CS_RS_Auth::has_strmd5passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CS_RS_Auth::set_has_strmd5passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CS_RS_Auth::clear_has_strmd5passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CS_RS_Auth::clear_strmd5passwd() {
  if (strmd5passwd_ != &::google::protobuf::internal::kEmptyString) {
    strmd5passwd_->clear();
  }
  clear_has_strmd5passwd();
}
inline const ::std::string& CS_RS_Auth::strmd5passwd() const {
  return *strmd5passwd_;
}
inline void CS_RS_Auth::set_strmd5passwd(const ::std::string& value) {
  set_has_strmd5passwd();
  if (strmd5passwd_ == &::google::protobuf::internal::kEmptyString) {
    strmd5passwd_ = new ::std::string;
  }
  strmd5passwd_->assign(value);
}
inline void CS_RS_Auth::set_strmd5passwd(const char* value) {
  set_has_strmd5passwd();
  if (strmd5passwd_ == &::google::protobuf::internal::kEmptyString) {
    strmd5passwd_ = new ::std::string;
  }
  strmd5passwd_->assign(value);
}
inline void CS_RS_Auth::set_strmd5passwd(const void* value, size_t size) {
  set_has_strmd5passwd();
  if (strmd5passwd_ == &::google::protobuf::internal::kEmptyString) {
    strmd5passwd_ = new ::std::string;
  }
  strmd5passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_RS_Auth::mutable_strmd5passwd() {
  set_has_strmd5passwd();
  if (strmd5passwd_ == &::google::protobuf::internal::kEmptyString) {
    strmd5passwd_ = new ::std::string;
  }
  return strmd5passwd_;
}
inline ::std::string* CS_RS_Auth::release_strmd5passwd() {
  clear_has_strmd5passwd();
  if (strmd5passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmd5passwd_;
    strmd5passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_RS_Auth::set_allocated_strmd5passwd(::std::string* strmd5passwd) {
  if (strmd5passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete strmd5passwd_;
  }
  if (strmd5passwd) {
    set_has_strmd5passwd();
    strmd5passwd_ = strmd5passwd;
  } else {
    clear_has_strmd5passwd();
    strmd5passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SC_RS_Auth

// required string strAccount = 1;
inline bool SC_RS_Auth::has_straccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SC_RS_Auth::set_has_straccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SC_RS_Auth::clear_has_straccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SC_RS_Auth::clear_straccount() {
  if (straccount_ != &::google::protobuf::internal::kEmptyString) {
    straccount_->clear();
  }
  clear_has_straccount();
}
inline const ::std::string& SC_RS_Auth::straccount() const {
  return *straccount_;
}
inline void SC_RS_Auth::set_straccount(const ::std::string& value) {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  straccount_->assign(value);
}
inline void SC_RS_Auth::set_straccount(const char* value) {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  straccount_->assign(value);
}
inline void SC_RS_Auth::set_straccount(const char* value, size_t size) {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  straccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SC_RS_Auth::mutable_straccount() {
  set_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    straccount_ = new ::std::string;
  }
  return straccount_;
}
inline ::std::string* SC_RS_Auth::release_straccount() {
  clear_has_straccount();
  if (straccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccount_;
    straccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SC_RS_Auth::set_allocated_straccount(::std::string* straccount) {
  if (straccount_ != &::google::protobuf::internal::kEmptyString) {
    delete straccount_;
  }
  if (straccount) {
    set_has_straccount();
    straccount_ = straccount;
  } else {
    clear_has_straccount();
    straccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 iRetCode = 2;
inline bool SC_RS_Auth::has_iretcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SC_RS_Auth::set_has_iretcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SC_RS_Auth::clear_has_iretcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SC_RS_Auth::clear_iretcode() {
  iretcode_ = 0;
  clear_has_iretcode();
}
inline ::google::protobuf::int32 SC_RS_Auth::iretcode() const {
  return iretcode_;
}
inline void SC_RS_Auth::set_iretcode(::google::protobuf::int32 value) {
  set_has_iretcode();
  iretcode_ = value;
}

// -------------------------------------------------------------------

// RSWorld

// required int32 iWorldID = 1;
inline bool RSWorld::has_iworldid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RSWorld::set_has_iworldid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RSWorld::clear_has_iworldid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RSWorld::clear_iworldid() {
  iworldid_ = 0;
  clear_has_iworldid();
}
inline ::google::protobuf::int32 RSWorld::iworldid() const {
  return iworldid_;
}
inline void RSWorld::set_iworldid(::google::protobuf::int32 value) {
  set_has_iworldid();
  iworldid_ = value;
}

// required string strWorldName = 2;
inline bool RSWorld::has_strworldname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RSWorld::set_has_strworldname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RSWorld::clear_has_strworldname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RSWorld::clear_strworldname() {
  if (strworldname_ != &::google::protobuf::internal::kEmptyString) {
    strworldname_->clear();
  }
  clear_has_strworldname();
}
inline const ::std::string& RSWorld::strworldname() const {
  return *strworldname_;
}
inline void RSWorld::set_strworldname(const ::std::string& value) {
  set_has_strworldname();
  if (strworldname_ == &::google::protobuf::internal::kEmptyString) {
    strworldname_ = new ::std::string;
  }
  strworldname_->assign(value);
}
inline void RSWorld::set_strworldname(const char* value) {
  set_has_strworldname();
  if (strworldname_ == &::google::protobuf::internal::kEmptyString) {
    strworldname_ = new ::std::string;
  }
  strworldname_->assign(value);
}
inline void RSWorld::set_strworldname(const char* value, size_t size) {
  set_has_strworldname();
  if (strworldname_ == &::google::protobuf::internal::kEmptyString) {
    strworldname_ = new ::std::string;
  }
  strworldname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RSWorld::mutable_strworldname() {
  set_has_strworldname();
  if (strworldname_ == &::google::protobuf::internal::kEmptyString) {
    strworldname_ = new ::std::string;
  }
  return strworldname_;
}
inline ::std::string* RSWorld::release_strworldname() {
  clear_has_strworldname();
  if (strworldname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strworldname_;
    strworldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RSWorld::set_allocated_strworldname(::std::string* strworldname) {
  if (strworldname_ != &::google::protobuf::internal::kEmptyString) {
    delete strworldname_;
  }
  if (strworldname) {
    set_has_strworldname();
    strworldname_ = strworldname;
  } else {
    clear_has_strworldname();
    strworldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 iAtt = 3;
inline bool RSWorld::has_iatt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RSWorld::set_has_iatt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RSWorld::clear_has_iatt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RSWorld::clear_iatt() {
  iatt_ = 0;
  clear_has_iatt();
}
inline ::google::protobuf::int32 RSWorld::iatt() const {
  return iatt_;
}
inline void RSWorld::set_iatt(::google::protobuf::int32 value) {
  set_has_iatt();
  iatt_ = value;
}

// required int32 iOnlineStatus = 4;
inline bool RSWorld::has_ionlinestatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RSWorld::set_has_ionlinestatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RSWorld::clear_has_ionlinestatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RSWorld::clear_ionlinestatus() {
  ionlinestatus_ = 0;
  clear_has_ionlinestatus();
}
inline ::google::protobuf::int32 RSWorld::ionlinestatus() const {
  return ionlinestatus_;
}
inline void RSWorld::set_ionlinestatus(::google::protobuf::int32 value) {
  set_has_ionlinestatus();
  ionlinestatus_ = value;
}

// required int32 iBusyStatus = 5;
inline bool RSWorld::has_ibusystatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RSWorld::set_has_ibusystatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RSWorld::clear_has_ibusystatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RSWorld::clear_ibusystatus() {
  ibusystatus_ = 0;
  clear_has_ibusystatus();
}
inline ::google::protobuf::int32 RSWorld::ibusystatus() const {
  return ibusystatus_;
}
inline void RSWorld::set_ibusystatus(::google::protobuf::int32 value) {
  set_has_ibusystatus();
  ibusystatus_ = value;
}

// optional bool bHaveRole = 6;
inline bool RSWorld::has_bhaverole() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RSWorld::set_has_bhaverole() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RSWorld::clear_has_bhaverole() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RSWorld::clear_bhaverole() {
  bhaverole_ = false;
  clear_has_bhaverole();
}
inline bool RSWorld::bhaverole() const {
  return bhaverole_;
}
inline void RSWorld::set_bhaverole(bool value) {
  set_has_bhaverole();
  bhaverole_ = value;
}

// -------------------------------------------------------------------

// SC_RS_WorldList

// repeated .ServerEngine.RSWorld worldList = 1;
inline int SC_RS_WorldList::worldlist_size() const {
  return worldlist_.size();
}
inline void SC_RS_WorldList::clear_worldlist() {
  worldlist_.Clear();
}
inline const ::ServerEngine::RSWorld& SC_RS_WorldList::worldlist(int index) const {
  return worldlist_.Get(index);
}
inline ::ServerEngine::RSWorld* SC_RS_WorldList::mutable_worldlist(int index) {
  return worldlist_.Mutable(index);
}
inline ::ServerEngine::RSWorld* SC_RS_WorldList::add_worldlist() {
  return worldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ServerEngine::RSWorld >&
SC_RS_WorldList::worldlist() const {
  return worldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ServerEngine::RSWorld >*
SC_RS_WorldList::mutable_worldlist() {
  return &worldlist_;
}

// -------------------------------------------------------------------

// RS_ROUTER_VERSION_SC

// required string strUrlDir = 1;
inline bool RS_ROUTER_VERSION_SC::has_strurldir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RS_ROUTER_VERSION_SC::set_has_strurldir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RS_ROUTER_VERSION_SC::clear_has_strurldir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RS_ROUTER_VERSION_SC::clear_strurldir() {
  if (strurldir_ != &::google::protobuf::internal::kEmptyString) {
    strurldir_->clear();
  }
  clear_has_strurldir();
}
inline const ::std::string& RS_ROUTER_VERSION_SC::strurldir() const {
  return *strurldir_;
}
inline void RS_ROUTER_VERSION_SC::set_strurldir(const ::std::string& value) {
  set_has_strurldir();
  if (strurldir_ == &::google::protobuf::internal::kEmptyString) {
    strurldir_ = new ::std::string;
  }
  strurldir_->assign(value);
}
inline void RS_ROUTER_VERSION_SC::set_strurldir(const char* value) {
  set_has_strurldir();
  if (strurldir_ == &::google::protobuf::internal::kEmptyString) {
    strurldir_ = new ::std::string;
  }
  strurldir_->assign(value);
}
inline void RS_ROUTER_VERSION_SC::set_strurldir(const char* value, size_t size) {
  set_has_strurldir();
  if (strurldir_ == &::google::protobuf::internal::kEmptyString) {
    strurldir_ = new ::std::string;
  }
  strurldir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RS_ROUTER_VERSION_SC::mutable_strurldir() {
  set_has_strurldir();
  if (strurldir_ == &::google::protobuf::internal::kEmptyString) {
    strurldir_ = new ::std::string;
  }
  return strurldir_;
}
inline ::std::string* RS_ROUTER_VERSION_SC::release_strurldir() {
  clear_has_strurldir();
  if (strurldir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strurldir_;
    strurldir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RS_ROUTER_VERSION_SC::set_allocated_strurldir(::std::string* strurldir) {
  if (strurldir_ != &::google::protobuf::internal::kEmptyString) {
    delete strurldir_;
  }
  if (strurldir) {
    set_has_strurldir();
    strurldir_ = strurldir;
  } else {
    clear_has_strurldir();
    strurldir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strVersion = 2;
inline bool RS_ROUTER_VERSION_SC::has_strversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RS_ROUTER_VERSION_SC::set_has_strversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RS_ROUTER_VERSION_SC::clear_has_strversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RS_ROUTER_VERSION_SC::clear_strversion() {
  if (strversion_ != &::google::protobuf::internal::kEmptyString) {
    strversion_->clear();
  }
  clear_has_strversion();
}
inline const ::std::string& RS_ROUTER_VERSION_SC::strversion() const {
  return *strversion_;
}
inline void RS_ROUTER_VERSION_SC::set_strversion(const ::std::string& value) {
  set_has_strversion();
  if (strversion_ == &::google::protobuf::internal::kEmptyString) {
    strversion_ = new ::std::string;
  }
  strversion_->assign(value);
}
inline void RS_ROUTER_VERSION_SC::set_strversion(const char* value) {
  set_has_strversion();
  if (strversion_ == &::google::protobuf::internal::kEmptyString) {
    strversion_ = new ::std::string;
  }
  strversion_->assign(value);
}
inline void RS_ROUTER_VERSION_SC::set_strversion(const char* value, size_t size) {
  set_has_strversion();
  if (strversion_ == &::google::protobuf::internal::kEmptyString) {
    strversion_ = new ::std::string;
  }
  strversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RS_ROUTER_VERSION_SC::mutable_strversion() {
  set_has_strversion();
  if (strversion_ == &::google::protobuf::internal::kEmptyString) {
    strversion_ = new ::std::string;
  }
  return strversion_;
}
inline ::std::string* RS_ROUTER_VERSION_SC::release_strversion() {
  clear_has_strversion();
  if (strversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strversion_;
    strversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RS_ROUTER_VERSION_SC::set_allocated_strversion(::std::string* strversion) {
  if (strversion_ != &::google::protobuf::internal::kEmptyString) {
    delete strversion_;
  }
  if (strversion) {
    set_has_strversion();
    strversion_ = strversion;
  } else {
    clear_has_strversion();
    strversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strMinVersion = 3;
inline bool RS_ROUTER_VERSION_SC::has_strminversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RS_ROUTER_VERSION_SC::set_has_strminversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RS_ROUTER_VERSION_SC::clear_has_strminversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RS_ROUTER_VERSION_SC::clear_strminversion() {
  if (strminversion_ != &::google::protobuf::internal::kEmptyString) {
    strminversion_->clear();
  }
  clear_has_strminversion();
}
inline const ::std::string& RS_ROUTER_VERSION_SC::strminversion() const {
  return *strminversion_;
}
inline void RS_ROUTER_VERSION_SC::set_strminversion(const ::std::string& value) {
  set_has_strminversion();
  if (strminversion_ == &::google::protobuf::internal::kEmptyString) {
    strminversion_ = new ::std::string;
  }
  strminversion_->assign(value);
}
inline void RS_ROUTER_VERSION_SC::set_strminversion(const char* value) {
  set_has_strminversion();
  if (strminversion_ == &::google::protobuf::internal::kEmptyString) {
    strminversion_ = new ::std::string;
  }
  strminversion_->assign(value);
}
inline void RS_ROUTER_VERSION_SC::set_strminversion(const char* value, size_t size) {
  set_has_strminversion();
  if (strminversion_ == &::google::protobuf::internal::kEmptyString) {
    strminversion_ = new ::std::string;
  }
  strminversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RS_ROUTER_VERSION_SC::mutable_strminversion() {
  set_has_strminversion();
  if (strminversion_ == &::google::protobuf::internal::kEmptyString) {
    strminversion_ = new ::std::string;
  }
  return strminversion_;
}
inline ::std::string* RS_ROUTER_VERSION_SC::release_strminversion() {
  clear_has_strminversion();
  if (strminversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strminversion_;
    strminversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RS_ROUTER_VERSION_SC::set_allocated_strminversion(::std::string* strminversion) {
  if (strminversion_ != &::google::protobuf::internal::kEmptyString) {
    delete strminversion_;
  }
  if (strminversion) {
    set_has_strminversion();
    strminversion_ = strminversion;
  } else {
    clear_has_strminversion();
    strminversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool noResUpdate = 4;
inline bool RS_ROUTER_VERSION_SC::has_noresupdate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RS_ROUTER_VERSION_SC::set_has_noresupdate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RS_ROUTER_VERSION_SC::clear_has_noresupdate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RS_ROUTER_VERSION_SC::clear_noresupdate() {
  noresupdate_ = false;
  clear_has_noresupdate();
}
inline bool RS_ROUTER_VERSION_SC::noresupdate() const {
  return noresupdate_;
}
inline void RS_ROUTER_VERSION_SC::set_noresupdate(bool value) {
  set_has_noresupdate();
  noresupdate_ = value;
}

// -------------------------------------------------------------------

// SC_RS_Error

// optional string strErrorMsg = 1;
inline bool SC_RS_Error::has_strerrormsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SC_RS_Error::set_has_strerrormsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SC_RS_Error::clear_has_strerrormsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SC_RS_Error::clear_strerrormsg() {
  if (strerrormsg_ != &::google::protobuf::internal::kEmptyString) {
    strerrormsg_->clear();
  }
  clear_has_strerrormsg();
}
inline const ::std::string& SC_RS_Error::strerrormsg() const {
  return *strerrormsg_;
}
inline void SC_RS_Error::set_strerrormsg(const ::std::string& value) {
  set_has_strerrormsg();
  if (strerrormsg_ == &::google::protobuf::internal::kEmptyString) {
    strerrormsg_ = new ::std::string;
  }
  strerrormsg_->assign(value);
}
inline void SC_RS_Error::set_strerrormsg(const char* value) {
  set_has_strerrormsg();
  if (strerrormsg_ == &::google::protobuf::internal::kEmptyString) {
    strerrormsg_ = new ::std::string;
  }
  strerrormsg_->assign(value);
}
inline void SC_RS_Error::set_strerrormsg(const char* value, size_t size) {
  set_has_strerrormsg();
  if (strerrormsg_ == &::google::protobuf::internal::kEmptyString) {
    strerrormsg_ = new ::std::string;
  }
  strerrormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SC_RS_Error::mutable_strerrormsg() {
  set_has_strerrormsg();
  if (strerrormsg_ == &::google::protobuf::internal::kEmptyString) {
    strerrormsg_ = new ::std::string;
  }
  return strerrormsg_;
}
inline ::std::string* SC_RS_Error::release_strerrormsg() {
  clear_has_strerrormsg();
  if (strerrormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strerrormsg_;
    strerrormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SC_RS_Error::set_allocated_strerrormsg(::std::string* strerrormsg) {
  if (strerrormsg_ != &::google::protobuf::internal::kEmptyString) {
    delete strerrormsg_;
  }
  if (strerrormsg) {
    set_has_strerrormsg();
    strerrormsg_ = strerrormsg;
  } else {
    clear_has_strerrormsg();
    strerrormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CS_RS_ALogin

// required int32 iWorldID = 1;
inline bool CS_RS_ALogin::has_iworldid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_RS_ALogin::set_has_iworldid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_RS_ALogin::clear_has_iworldid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_RS_ALogin::clear_iworldid() {
  iworldid_ = 0;
  clear_has_iworldid();
}
inline ::google::protobuf::int32 CS_RS_ALogin::iworldid() const {
  return iworldid_;
}
inline void CS_RS_ALogin::set_iworldid(::google::protobuf::int32 value) {
  set_has_iworldid();
  iworldid_ = value;
}

// required bytes strTransMsg = 2;
inline bool CS_RS_ALogin::has_strtransmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CS_RS_ALogin::set_has_strtransmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CS_RS_ALogin::clear_has_strtransmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CS_RS_ALogin::clear_strtransmsg() {
  if (strtransmsg_ != &::google::protobuf::internal::kEmptyString) {
    strtransmsg_->clear();
  }
  clear_has_strtransmsg();
}
inline const ::std::string& CS_RS_ALogin::strtransmsg() const {
  return *strtransmsg_;
}
inline void CS_RS_ALogin::set_strtransmsg(const ::std::string& value) {
  set_has_strtransmsg();
  if (strtransmsg_ == &::google::protobuf::internal::kEmptyString) {
    strtransmsg_ = new ::std::string;
  }
  strtransmsg_->assign(value);
}
inline void CS_RS_ALogin::set_strtransmsg(const char* value) {
  set_has_strtransmsg();
  if (strtransmsg_ == &::google::protobuf::internal::kEmptyString) {
    strtransmsg_ = new ::std::string;
  }
  strtransmsg_->assign(value);
}
inline void CS_RS_ALogin::set_strtransmsg(const void* value, size_t size) {
  set_has_strtransmsg();
  if (strtransmsg_ == &::google::protobuf::internal::kEmptyString) {
    strtransmsg_ = new ::std::string;
  }
  strtransmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_RS_ALogin::mutable_strtransmsg() {
  set_has_strtransmsg();
  if (strtransmsg_ == &::google::protobuf::internal::kEmptyString) {
    strtransmsg_ = new ::std::string;
  }
  return strtransmsg_;
}
inline ::std::string* CS_RS_ALogin::release_strtransmsg() {
  clear_has_strtransmsg();
  if (strtransmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strtransmsg_;
    strtransmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_RS_ALogin::set_allocated_strtransmsg(::std::string* strtransmsg) {
  if (strtransmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete strtransmsg_;
  }
  if (strtransmsg) {
    set_has_strtransmsg();
    strtransmsg_ = strtransmsg;
  } else {
    clear_has_strtransmsg();
    strtransmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ServerEngine

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerEngine::enBusyStatus>() {
  return ::ServerEngine::enBusyStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerEngine::RouterServerCMD>() {
  return ::ServerEngine::RouterServerCMD_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerEngine::RSAuthCode>() {
  return ::ServerEngine::RSAuthCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RouterServer_2eproto__INCLUDED
