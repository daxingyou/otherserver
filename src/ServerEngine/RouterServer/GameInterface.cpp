// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `GameInterface.jce'
// **********************************************************************

#include "GameInterface.h"
#include "jce/wup.h"
#include "servant/BaseF.h"

using namespace wup;

namespace ServerEngine
{

    taf::Int32 GameProxy::Comm_Pay_AddMoney(const std::string &strAccount, taf::Int32 iWorldID, taf::Int32 iCount, const std::string &strChannel, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(iWorldID, 2);
        _os.write(iCount, 3);
        _os.write(strChannel, 4);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"Comm_Pay_AddMoney", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_Comm_Pay_AddMoney(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_Comm_Pay_AddMoney(GamePrxCallbackPtr callback,const std::string &strAccount,taf::Int32 iWorldID,taf::Int32 iCount,const std::string &strChannel,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(iWorldID, 2);
        _os.write(iCount, 3);
        _os.write(strChannel, 4);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"Comm_Pay_AddMoney", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::GMOnlneRollMessage(const std::string &strMsg, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strMsg, 1);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"GMOnlneRollMessage", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_GMOnlneRollMessage(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_GMOnlneRollMessage(GamePrxCallbackPtr callback,const std::string &strMsg,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strMsg, 1);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"GMOnlneRollMessage", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::LJSDK_Pay_AddMoney(const std::string &strAccount, taf::Int32 iWorldID, taf::Int32 iCount, const std::string &strChannel, const std::string &strOrderId, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(iWorldID, 2);
        _os.write(iCount, 3);
        _os.write(strChannel, 4);
        _os.write(strOrderId, 5);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"LJSDK_Pay_AddMoney", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_LJSDK_Pay_AddMoney(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_LJSDK_Pay_AddMoney(GamePrxCallbackPtr callback,const std::string &strAccount,taf::Int32 iWorldID,taf::Int32 iCount,const std::string &strChannel,const std::string &strOrderId,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(iWorldID, 2);
        _os.write(iCount, 3);
        _os.write(strChannel, 4);
        _os.write(strOrderId, 5);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"LJSDK_Pay_AddMoney", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::TbT_AddMoney(const std::string &strAccount, taf::Int32 iWorldID, taf::Int32 iCount, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(iWorldID, 2);
        _os.write(iCount, 3);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"TbT_AddMoney", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_TbT_AddMoney(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_TbT_AddMoney(GamePrxCallbackPtr callback,const std::string &strAccount,taf::Int32 iWorldID,taf::Int32 iCount,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(iWorldID, 2);
        _os.write(iCount, 3);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"TbT_AddMoney", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::doNotifyLoginOff(const std::string &strAccount, taf::Short nLoginOffCode, const std::string &sRsObjAddr, taf::Int64 iConnId, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(nLoginOffCode, 2);
        _os.write(sRsObjAddr, 3);
        _os.write(iConnId, 4);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"doNotifyLoginOff", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_doNotifyLoginOff(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_doNotifyLoginOff(GamePrxCallbackPtr callback,const std::string &strAccount,taf::Short nLoginOffCode,const std::string &sRsObjAddr,taf::Int64 iConnId,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strAccount, 1);
        _os.write(nLoginOffCode, 2);
        _os.write(sRsObjAddr, 3);
        _os.write(iConnId, 4);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"doNotifyLoginOff", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::doRequest(taf::Int64 iConnId, const std::string &strAccount, taf::Int32 iWorldID, const std::string &sMsgPack, const std::string &sRsObjAddr, const map<std::string, std::string> &mClientParam, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(iConnId, 1);
        _os.write(strAccount, 2);
        _os.write(iWorldID, 3);
        _os.write(sMsgPack, 4);
        _os.write(sRsObjAddr, 5);
        _os.write(mClientParam, 6);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"doRequest", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_doRequest(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_doRequest(GamePrxCallbackPtr callback,taf::Int64 iConnId,const std::string &strAccount,taf::Int32 iWorldID,const std::string &sMsgPack,const std::string &sRsObjAddr,const map<std::string, std::string> &mClientParam,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(iConnId, 1);
        _os.write(strAccount, 2);
        _os.write(iWorldID, 3);
        _os.write(sMsgPack, 4);
        _os.write(sRsObjAddr, 5);
        _os.write(mClientParam, 6);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"doRequest", _os.getByteBuffer(), context, status, callback);
    }

    void GameProxy::getGameStatus(ServerEngine::GameQueryStatus &gameStatus, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(gameStatus, 1);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"getGameStatus", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        _is.read(gameStatus, 1, true);
    }

    void Game::async_response_getGameStatus(taf::JceCurrentPtr current, const ServerEngine::GameQueryStatus &gameStatus)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("gameStatus", gameStatus);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(gameStatus, 1);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_getGameStatus(GamePrxCallbackPtr callback,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"getGameStatus", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::getLegionMember(const std::string &strLegionName, std::string &strJson, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strLegionName, 1);
        _os.write(strJson, 2);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"getLegionMember", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(strJson, 2, true);
        return _ret;
    }

    void Game::async_response_getLegionMember(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &strJson)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("strJson", strJson);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(strJson, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_getLegionMember(GamePrxCallbackPtr callback,const std::string &strLegionName,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(strLegionName, 1);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"getLegionMember", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::getRoleBagData(const ServerEngine::PKRole &pkRole, std::string &strJson, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        _os.write(strJson, 2);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"getRoleBagData", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(strJson, 2, true);
        return _ret;
    }

    void Game::async_response_getRoleBagData(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &strJson)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("strJson", strJson);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(strJson, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_getRoleBagData(GamePrxCallbackPtr callback,const ServerEngine::PKRole &pkRole,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"getRoleBagData", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::getRoleBaseData(const ServerEngine::PKRole &pkRole, std::string &strJson, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        _os.write(strJson, 2);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"getRoleBaseData", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(strJson, 2, true);
        return _ret;
    }

    void Game::async_response_getRoleBaseData(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &strJson)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("strJson", strJson);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(strJson, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_getRoleBaseData(GamePrxCallbackPtr callback,const ServerEngine::PKRole &pkRole,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"getRoleBaseData", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::getRoleHeroData(const ServerEngine::PKRole &pkRole, std::string &strJson, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        _os.write(strJson, 2);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"getRoleHeroData", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        _is.read(strJson, 2, true);
        return _ret;
    }

    void Game::async_response_getRoleHeroData(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &strJson)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);
            tafAttr.put("strJson", strJson);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            _os.write(strJson, 2);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_getRoleHeroData(GamePrxCallbackPtr callback,const ServerEngine::PKRole &pkRole,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"getRoleHeroData", _os.getByteBuffer(), context, status, callback);
    }

    taf::Int32 GameProxy::sendRoleMail(const ServerEngine::PKRole &pkRole, const map<std::string, std::string> &mailMap, const map<string, string> &context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        _os.write(mailMap, 2);
        taf::ResponsePacket rep;
        std::map<string, string> status;
        taf_invoke(taf::JCENORMAL,"sendRoleMail", _os.getByteBuffer(), context, status, rep);
        taf::JceInputStream<taf::BufferReader> _is;
        _is.setBuffer(rep.sBuffer);
        taf::Int32 _ret;
        _is.read(_ret, 0, true);
        return _ret;
    }

    void Game::async_response_sendRoleMail(taf::JceCurrentPtr current, taf::Int32 _ret)
    {
        if (current->getRequestVersion() == WUPVERSION || current->getRequestVersion() == WUPVERSION2)
        {
            UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
            tafAttr.setVersion(current->getRequestVersion());
            tafAttr.put("", _ret);

            vector<char> sWupResponseBuffer;
            tafAttr.encode(sWupResponseBuffer);
            current->sendResponse(taf::JCESERVERSUCCESS, sWupResponseBuffer);
        }
        else
        {
            taf::JceOutputStream<taf::BufferWriter> _os;
            _os.write(_ret, 0);

            current->sendResponse(taf::JCESERVERSUCCESS, _os.getByteBuffer());
        }
    }

    void GameProxy::async_sendRoleMail(GamePrxCallbackPtr callback,const ServerEngine::PKRole &pkRole,const map<std::string, std::string> &mailMap,const map<string, string>& context)
    {
        taf::JceOutputStream<taf::BufferWriter> _os;
        _os.write(pkRole, 1);
        _os.write(mailMap, 2);
        std::map<string, string> status;
        taf_invoke_async(taf::JCENORMAL,"sendRoleMail", _os.getByteBuffer(), context, status, callback);
    }

    GameProxy* GameProxy::taf_hash(int64_t key)
    {
        return (GameProxy*)ServantProxy::taf_hash(key);
    }

    static ::std::string __ServerEngine__Game_all[]=
    {
        "Comm_Pay_AddMoney",
        "GMOnlneRollMessage",
        "LJSDK_Pay_AddMoney",
        "TbT_AddMoney",
        "doNotifyLoginOff",
        "doRequest",
        "getGameStatus",
        "getLegionMember",
        "getRoleBagData",
        "getRoleBaseData",
        "getRoleHeroData",
        "sendRoleMail"
    };

    int GamePrxCallback::onDispatch(taf::ReqMessagePtr msg)
    {
        pair<string*, string*> r = equal_range(__ServerEngine__Game_all, __ServerEngine__Game_all+12, msg->request.sFuncName);
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __ServerEngine__Game_all)
        {
            case 0:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_Comm_Pay_AddMoney_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_Comm_Pay_AddMoney(_ret);
                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_GMOnlneRollMessage_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_GMOnlneRollMessage(_ret);
                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_LJSDK_Pay_AddMoney_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_LJSDK_Pay_AddMoney(_ret);
                return taf::JCESERVERSUCCESS;

            }
            case 3:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_TbT_AddMoney_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_TbT_AddMoney(_ret);
                return taf::JCESERVERSUCCESS;

            }
            case 4:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_doNotifyLoginOff_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_doNotifyLoginOff(_ret);
                return taf::JCESERVERSUCCESS;

            }
            case 5:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_doRequest_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_doRequest(_ret);
                return taf::JCESERVERSUCCESS;

            }
            case 6:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getGameStatus_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                ServerEngine::GameQueryStatus gameStatus;
                _is.read(gameStatus, 1, true);
                callback_getGameStatus(gameStatus);
                return taf::JCESERVERSUCCESS;

            }
            case 7:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getLegionMember_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                std::string strJson;
                _is.read(strJson, 2, true);
                callback_getLegionMember(_ret, strJson);
                return taf::JCESERVERSUCCESS;

            }
            case 8:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getRoleBagData_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                std::string strJson;
                _is.read(strJson, 2, true);
                callback_getRoleBagData(_ret, strJson);
                return taf::JCESERVERSUCCESS;

            }
            case 9:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getRoleBaseData_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                std::string strJson;
                _is.read(strJson, 2, true);
                callback_getRoleBaseData(_ret, strJson);
                return taf::JCESERVERSUCCESS;

            }
            case 10:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_getRoleHeroData_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                std::string strJson;
                _is.read(strJson, 2, true);
                callback_getRoleHeroData(_ret, strJson);
                return taf::JCESERVERSUCCESS;

            }
            case 11:
            {
                if (msg->response.iRet != taf::JCESERVERSUCCESS)
                {
                    callback_sendRoleMail_exception(msg->response.iRet);

                    return msg->response.iRet;
                }
                taf::JceInputStream<taf::BufferReader> _is;

                _is.setBuffer(msg->response.sBuffer);
                taf::Int32 _ret;
                _is.read(_ret, 0, true);

                callback_sendRoleMail(_ret);
                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }

    int Game::onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer)
    {
        pair<string*, string*> r = equal_range(__ServerEngine__Game_all, __ServerEngine__Game_all+12, _current->getFuncName());
        if(r.first == r.second) return taf::JCESERVERNOFUNCERR;
        switch(r.first - __ServerEngine__Game_all)
        {
            case 0:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string strAccount;
                taf::Int32 iWorldID;
                taf::Int32 iCount;
                std::string strChannel;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("strAccount", strAccount);
                    tafAttr.get("iWorldID", iWorldID);
                    tafAttr.get("iCount", iCount);
                    tafAttr.get("strChannel", strChannel);
                }
                else
                {
                    _is.read(strAccount, 1, true);
                    _is.read(iWorldID, 2, true);
                    _is.read(iCount, 3, true);
                    _is.read(strChannel, 4, true);
                }
                taf::Int32 _ret = Comm_Pay_AddMoney(strAccount,iWorldID,iCount,strChannel, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 1:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string strMsg;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("strMsg", strMsg);
                }
                else
                {
                    _is.read(strMsg, 1, true);
                }
                taf::Int32 _ret = GMOnlneRollMessage(strMsg, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 2:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string strAccount;
                taf::Int32 iWorldID;
                taf::Int32 iCount;
                std::string strChannel;
                std::string strOrderId;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("strAccount", strAccount);
                    tafAttr.get("iWorldID", iWorldID);
                    tafAttr.get("iCount", iCount);
                    tafAttr.get("strChannel", strChannel);
                    tafAttr.get("strOrderId", strOrderId);
                }
                else
                {
                    _is.read(strAccount, 1, true);
                    _is.read(iWorldID, 2, true);
                    _is.read(iCount, 3, true);
                    _is.read(strChannel, 4, true);
                    _is.read(strOrderId, 5, true);
                }
                taf::Int32 _ret = LJSDK_Pay_AddMoney(strAccount,iWorldID,iCount,strChannel,strOrderId, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 3:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string strAccount;
                taf::Int32 iWorldID;
                taf::Int32 iCount;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("strAccount", strAccount);
                    tafAttr.get("iWorldID", iWorldID);
                    tafAttr.get("iCount", iCount);
                }
                else
                {
                    _is.read(strAccount, 1, true);
                    _is.read(iWorldID, 2, true);
                    _is.read(iCount, 3, true);
                }
                taf::Int32 _ret = TbT_AddMoney(strAccount,iWorldID,iCount, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 4:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string strAccount;
                taf::Short nLoginOffCode;
                std::string sRsObjAddr;
                taf::Int64 iConnId;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("strAccount", strAccount);
                    tafAttr.get("nLoginOffCode", nLoginOffCode);
                    tafAttr.get("sRsObjAddr", sRsObjAddr);
                    tafAttr.get("iConnId", iConnId);
                }
                else
                {
                    _is.read(strAccount, 1, true);
                    _is.read(nLoginOffCode, 2, true);
                    _is.read(sRsObjAddr, 3, true);
                    _is.read(iConnId, 4, true);
                }
                taf::Int32 _ret = doNotifyLoginOff(strAccount,nLoginOffCode,sRsObjAddr,iConnId, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 5:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                taf::Int64 iConnId;
                std::string strAccount;
                taf::Int32 iWorldID;
                std::string sMsgPack;
                std::string sRsObjAddr;
                map<std::string, std::string> mClientParam;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("iConnId", iConnId);
                    tafAttr.get("strAccount", strAccount);
                    tafAttr.get("iWorldID", iWorldID);
                    tafAttr.get("sMsgPack", sMsgPack);
                    tafAttr.get("sRsObjAddr", sRsObjAddr);
                    tafAttr.get("mClientParam", mClientParam);
                }
                else
                {
                    _is.read(iConnId, 1, true);
                    _is.read(strAccount, 2, true);
                    _is.read(iWorldID, 3, true);
                    _is.read(sMsgPack, 4, true);
                    _is.read(sRsObjAddr, 5, true);
                    _is.read(mClientParam, 6, true);
                }
                taf::Int32 _ret = doRequest(iConnId,strAccount,iWorldID,sMsgPack,sRsObjAddr,mClientParam, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 6:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                ServerEngine::GameQueryStatus gameStatus;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.getByDefault("gameStatus", gameStatus, gameStatus);
                }
                else
                {
                    _is.read(gameStatus, 1, false);
                }
                getGameStatus(gameStatus, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("gameStatus", gameStatus);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(gameStatus, 1);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 7:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                std::string strLegionName;
                std::string strJson;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("strLegionName", strLegionName);
                    tafAttr.getByDefault("strJson", strJson, strJson);
                }
                else
                {
                    _is.read(strLegionName, 1, true);
                    _is.read(strJson, 2, false);
                }
                taf::Int32 _ret = getLegionMember(strLegionName,strJson, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("strJson", strJson);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(strJson, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 8:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                ServerEngine::PKRole pkRole;
                std::string strJson;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("pkRole", pkRole);
                    tafAttr.getByDefault("strJson", strJson, strJson);
                }
                else
                {
                    _is.read(pkRole, 1, true);
                    _is.read(strJson, 2, false);
                }
                taf::Int32 _ret = getRoleBagData(pkRole,strJson, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("strJson", strJson);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(strJson, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 9:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                ServerEngine::PKRole pkRole;
                std::string strJson;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("pkRole", pkRole);
                    tafAttr.getByDefault("strJson", strJson, strJson);
                }
                else
                {
                    _is.read(pkRole, 1, true);
                    _is.read(strJson, 2, false);
                }
                taf::Int32 _ret = getRoleBaseData(pkRole,strJson, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("strJson", strJson);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(strJson, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 10:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                ServerEngine::PKRole pkRole;
                std::string strJson;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("pkRole", pkRole);
                    tafAttr.getByDefault("strJson", strJson, strJson);
                }
                else
                {
                    _is.read(pkRole, 1, true);
                    _is.read(strJson, 2, false);
                }
                taf::Int32 _ret = getRoleHeroData(pkRole,strJson, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.put("strJson", strJson);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.write(strJson, 2);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
            case 11:
            {
                taf::JceInputStream<taf::BufferReader> _is;
                _is.setBuffer(_current->getRequestBuffer());
                ServerEngine::PKRole pkRole;
                map<std::string, std::string> mailMap;
                if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                {
                    UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                    tafAttr.setVersion(_current->getRequestVersion());
                    tafAttr.decode(_current->getRequestBuffer());
                    tafAttr.get("pkRole", pkRole);
                    tafAttr.get("mailMap", mailMap);
                }
                else
                {
                    _is.read(pkRole, 1, true);
                    _is.read(mailMap, 2, true);
                }
                taf::Int32 _ret = sendRoleMail(pkRole,mailMap, _current);
                if(_current->isResponse())
                {
                    if (_current->getRequestVersion() == WUPVERSION || _current->getRequestVersion() == WUPVERSION2)
                    {
                        UniAttribute<taf::BufferWriter, taf::BufferReader>  tafAttr;
                        tafAttr.setVersion(_current->getRequestVersion());
                        tafAttr.put("", _ret);
                        tafAttr.encode(_sResponseBuffer);
                    }
                    else
                    {
                        taf::JceOutputStream<taf::BufferWriter> _os;
                        _os.write(_ret, 0);
                        _os.swap(_sResponseBuffer);
                    }
                }
                return taf::JCESERVERSUCCESS;

            }
        }
        return taf::JCESERVERNOFUNCERR;
    }


}

